# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# playbooks/chaos/restore_all.yml
# ëª©ì : ëª¨ë“  ì¹´ì˜¤ìŠ¤ í…ŒìŠ¤íŠ¸ ì´í›„ ì „ì²´ ë³µêµ¬ ìˆ˜í–‰ (í†µí•© ë³µì›)
# í‘œì¤€ ë³€ìˆ˜:
#   target_namespace, recovery_targets, chaos_log_path, recovery_wait
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

- name: ğŸ› ï¸  Perform Unified Service Recovery
  hosts: k3s_master
  become: yes
  vars:
    target_namespace: "app"
    recovery_targets:
      - cartservice
      - checkoutservice
      - paymentservice
      - redis-cart
    chaos_log_path: "/var/log/chaos_test.log"
    recovery_wait: 10

  tasks:
    # Step 1ï¸âƒ£: Safety Check
    - name: ğŸ§© Validate target namespace
      ansible.builtin.assert:
        that:
          - target_namespace == "app"
        fail_msg: "âŒ namespaceê°€ 'app'ì´ ì•„ë‹™ë‹ˆë‹¤. ë³µêµ¬ëŠ” app ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‚´ì—ì„œë§Œ ìˆ˜í–‰ ê°€ëŠ¥í•©ë‹ˆë‹¤."
        success_msg: "âœ… namespace í™•ì¸ ì™„ë£Œ ({{ target_namespace }})"

    # Step 2ï¸âƒ£: Log Start Message
    - name: ğŸ§¾ Announce recovery start
      ansible.builtin.debug:
        msg: |
          ğŸ› ï¸  ì „ì²´ ë³µêµ¬ ì‹œì‘
          - ëŒ€ìƒ ë„¤ì„ìŠ¤í˜ì´ìŠ¤: {{ target_namespace }}
          - ëŒ€ìƒ ì„œë¹„ìŠ¤: {{ recovery_targets | join(', ') }}
          - ì•ˆì •í™” ëŒ€ê¸° ì‹œê°„: {{ recovery_wait }}ì´ˆ

    # Step 3ï¸âƒ£: Restart deployments
    - name: ğŸ” Restart all target deployments
      ansible.builtin.shell: |
        for svc in {{ recovery_targets | join(' ') }}; do
          echo "[RESTORE] rollout restart deployment/$svc ..."
          kubectl rollout restart deployment/$svc -n {{ target_namespace }} || echo "[WARN] $svc restart ì‹¤íŒ¨"
        done
      register: restart_output
      ignore_errors: yes
      changed_when: true

    - name: ğŸ§¾ Show restart output
      ansible.builtin.debug:
        var: restart_output.stdout_lines

    # Step 4ï¸âƒ£: Wait for stabilization
    - name: â³ Wait for pods to stabilize
      ansible.builtin.pause:
        seconds: "{{ recovery_wait }}"

    # Step 5ï¸âƒ£: Verify recovery state
    - name: ğŸ” Check status of all deployments
      ansible.builtin.shell: |
        kubectl get deployments -n {{ target_namespace }} \
          -o custom-columns="NAME:.metadata.name,READY:.status.readyReplicas,DESIRED:.status.replicas" --no-headers
      register: deploy_status
      changed_when: false
      ignore_errors: yes

    - name: ğŸ§¾ Display deployment readiness
      ansible.builtin.debug:
        msg: |
          ğŸ“Š í˜„ì¬ ë°°í¬ ìƒíƒœ:
          {{ deploy_status.stdout | default('ì •ë³´ ì—†ìŒ') }}

    # Step 6ï¸âƒ£: Check for pending/crash pods
    - name: âš ï¸ Detect non-running pods
      ansible.builtin.shell: |
        kubectl get pods -n {{ target_namespace }} --field-selector=status.phase!=Running -o wide --no-headers || true
      register: non_running_pods
      changed_when: false
      ignore_errors: yes

    - name: ğŸ§¾ Show non-running pods (if any)
      ansible.builtin.debug:
        var: non_running_pods.stdout_lines

    # Step 6ï¸âƒ£.5ï¸âƒ£: Force restart non-running pods (optional pod-level recovery)
    - name: ğŸ§¹ Force delete non-running pods for recovery
      when: non_running_pods.stdout is defined and (non_running_pods.stdout | trim | length > 0)
      ansible.builtin.shell: |
        echo "âš™ï¸ ë¹„ì •ìƒ Pod ê°•ì œ ì‚­ì œ ì¤‘..."
        kubectl get pods -n {{ target_namespace }} --field-selector=status.phase!=Running -o name | \
        xargs -r -n1 kubectl delete -n {{ target_namespace }} --grace-period=0 --force || true
      register: forced_recovery
      ignore_errors: yes
      changed_when: true

    - name: ğŸ§¾ Print forced pod recovery result
      when: forced_recovery is defined
      ansible.builtin.debug:
        msg: |
          ğŸ§¹ ë¹„ì •ìƒ Pod ì‚­ì œ ê²°ê³¼:
          {{ forced_recovery.stdout | default('ì‚­ì œëœ Pod ì—†ìŒ') }}

    # Step 7ï¸âƒ£: Wait again for stabilization after forced recovery
    - name: â³ Wait again after pod-level recovery
      when: forced_recovery is defined
      ansible.builtin.pause:
        seconds: "{{ recovery_wait }}"

    # Step 8ï¸âƒ£: Verify final state
    - name: ğŸ” Check final running pods
      ansible.builtin.shell: |
        kubectl get pods -n {{ target_namespace }} --no-headers | grep -v Running || true
      register: final_nonrunning
      changed_when: false
      ignore_errors: yes

    # Step 9ï¸âƒ£: Log Recovery Results
    - name: ğŸª¶ Write recovery summary to log
      ansible.builtin.lineinfile:
        path: "{{ chaos_log_path }}"
        create: yes
        line: |
          [{{ ansible_date_time.iso8601 }}] Recovery: ns={{ target_namespace }} targets={{ recovery_targets | join(',') }} result="{{ deploy_status.stdout | replace('\n','; ') }}" issues="{{ non_running_pods.stdout | replace('\n','; ') }}" final_issues="{{ final_nonrunning.stdout | replace('\n','; ') }}"
      become: true

    # Step ğŸ”Ÿ: Final summary output
    - name: âœ… Print final recovery summary
      ansible.builtin.debug:
        msg: |
          âœ… ì „ì²´ ë³µêµ¬ ì™„ë£Œ
          - ë³µêµ¬ ëŒ€ìƒ: {{ recovery_targets | join(', ') }}
          - 1ì°¨ ë¹„ì •ìƒ Pod:
          {{ non_running_pods.stdout | default('ì—†ìŒ (ëª¨ë‘ Running)') }}
          - 2ì°¨ í™•ì¸(ê°•ì œë³µêµ¬ í›„ ë‚¨ì€ Pod):
          {{ final_nonrunning.stdout | default('ì—†ìŒ (ëª¨ë‘ ì •ìƒ)') }}


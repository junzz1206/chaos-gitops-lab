# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# íŒŒì¼ëª…: playbooks/chaos/restore_all.yml
# ëª©ì :
#   - CPU / Network chaos ë¶€í•˜ ì™„ì „ ë³µêµ¬
#   - ì„ì‹œ Chaos Pod ë° ë¦¬ì†ŒìŠ¤ ì •ë¦¬
#   - scale 0 â†’ 1 ë³µì›, Ready ë¶ˆì¼ì¹˜ ìë™ ìˆ˜ì •
#   - Redis â†” Cartservice ì˜ì¡´ì„± ìë™ ì¬ì •ë ¬
#   - âœ… GitLab / ArgoCD / Jenkins ë“± CI/CD í™˜ê²½ ì™„ì „ í˜¸í™˜
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

- name: ğŸ› ï¸ Perform Unified Chaos Recovery (CI/CD Compatible)
  hosts: k3s_master
  become: yes

  vars:
    # CI/CD í™˜ê²½ ë³€ìˆ˜ ê¸°ë°˜ ì„¤ì • (fallback í¬í•¨)
    target_namespace: "{{ lookup('env','TARGET_NAMESPACE') | default('app', true) }}"
    chaos_log_path: "{{ lookup('env','CHAOS_LOG_PATH') | default('/var/log/chaos_test.log', true) }}"
    recovery_wait: "{{ lookup('env','RECOVERY_WAIT') | default(15, true) | int }}"
    recovery_targets: >-
      {{ lookup('env','RECOVERY_TARGETS') |
         default('cartservice,checkoutservice,paymentservice,redis-cart,currencyservice,shippingservice,frontend,emailservice,productcatalogservice,recommendationservice', true)
         .split(',') }}

  tasks:

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 0ï¸âƒ£ CPU / Network Chaos ë³µì›
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Restore CPU and network chaos (internal + external)
      block:
        - ansible.builtin.shell: |
            echo "[CLEANUP] Restoring CPU and network chaos effects..."

            # ë…¸ë“œ ë‹¨ìœ„ ë³µì›
            echo "[NODE] Cleaning tc qdisc & killing stress-ng on nodes..."
            kubectl run chaos-cleaner --image=alpine --restart=Never -n {{ target_namespace }} --overrides='{
              "spec": {
                "hostPID": true,
                "containers": [{
                  "name": "cleanup",
                  "image": "alpine",
                  "securityContext": { "privileged": true },
                  "command": ["sh","-c",
                    "apk add --no-cache iproute2 procps >/dev/null; \
                     tc qdisc del dev eth0 root 2>/dev/null || true; \
                     pkill stress-ng 2>/dev/null || true; \
                     echo [OK] Node-level cleanup done."]
                }]
              }
            }' || true

            # Pod ë‚´ë¶€ ë³µì›
            echo "[POD] Cleaning tc & stress-ng inside pods..."
            PODS=$(kubectl get pods -n {{ target_namespace }} -o jsonpath='{.items[*].metadata.name}')
            for POD in $PODS; do
              kubectl exec -n {{ target_namespace }} $POD -- sh -c "
                if command -v tc >/dev/null 2>&1; then tc qdisc del dev eth0 root 2>/dev/null || true; fi
                if command -v pkill >/dev/null 2>&1; then pkill stress-ng 2>/dev/null || true; fi
              " || true
            done

            echo "[DONE] CPU/Network chaos recovery completed."
          register: cleanup_result
          ignore_errors: yes
          changed_when: true

      rescue:
        - name: Handle manual cancellation during CI/CD
          ansible.builtin.debug:
            msg: "ğŸ›‘ CI/CD manual stop detected â€” Recovery aborted safely."

        - name: Log abort state
          ansible.builtin.lineinfile:
            path: "{{ chaos_log_path }}"
            create: yes
            line: "[{{ ansible_date_time.iso8601 }}] Recovery aborted manually (CI/CD stop)"
          become: yes

        - ansible.builtin.meta: end_play

    - name: Show cleanup summary
      ansible.builtin.debug:
        var: cleanup_result.stdout_lines

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1ï¸âƒ£ Chaos ê´€ë ¨ ì„ì‹œ Pod ì •ë¦¬
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Delete leftover chaos pods
      ansible.builtin.shell: |
        CHAOS_PODS=$(kubectl get pods -n {{ target_namespace }} -o name | grep -E '^pod/(cpu-stress|net-chaos|network-chaos|svc-chaos)' || true)
        if [ -n "$CHAOS_PODS" ]; then
          echo "[CLEANUP] Removing chaos pods..."
          for p in $CHAOS_PODS; do
            kubectl delete $p -n {{ target_namespace }} --grace-period=0 --force || true
          done
        else
          echo "[INFO] No chaos pods found."
        fi
      register: pod_cleanup
      ignore_errors: yes
      changed_when: true

    - name: Show chaos pod cleanup result
      ansible.builtin.debug:
        var: pod_cleanup.stdout_lines

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2ï¸âƒ£ Namespace ê²€ì¦
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Validate target namespace
      ansible.builtin.assert:
        that:
          - target_namespace == "app"
        fail_msg: "âŒ namespaceê°€ 'app'ì´ ì•„ë‹™ë‹ˆë‹¤. ë³µêµ¬ëŠ” app ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‚´ì—ì„œë§Œ ìˆ˜í–‰ë©ë‹ˆë‹¤."
        success_msg: "âœ… namespace í™•ì¸ ì™„ë£Œ ({{ target_namespace }})"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3ï¸âƒ£ scale 0 â†’ 1 ë³µì›
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Restore deployments scaled to zero
      ansible.builtin.shell: |
        for svc in {{ recovery_targets | join(' ') }}; do
          replicas=$(kubectl get deploy $svc -n {{ target_namespace }} -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "")
          if [ "$replicas" = "0" ]; then
            echo "[RESTORE] Scaling $svc from 0 â†’ 1"
            kubectl scale deploy $svc -n {{ target_namespace }} --replicas=1 || true
          fi
        done
      register: scale_restore
      ignore_errors: yes
      changed_when: true

    - name: Show scale restore output
      ansible.builtin.debug:
        var: scale_restore.stdout_lines

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4ï¸âƒ£ ëˆ„ë½ Deployment ì¬ë°°í¬
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Redeploy missing services
      ansible.builtin.shell: |
        for svc in {{ recovery_targets | join(' ') }}; do
          if ! kubectl get deploy $svc -n {{ target_namespace }} >/dev/null 2>&1; then
            if [ -f "{{ playbook_dir }}/../app/$svc.yaml" ]; then
              echo "[AUTO-DEPLOY] Recreating missing $svc"
              kubectl apply -f {{ playbook_dir }}/../app/$svc.yaml || true
            fi
          fi
        done
      register: redeploy_result
      ignore_errors: yes
      changed_when: true

    - name: Show redeploy actions
      ansible.builtin.debug:
        var: redeploy_result.stdout_lines

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5ï¸âƒ£ Ready â‰  Desired â†’ Rollout ì¬ì‹œì‘
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Restart unready deployments
      ansible.builtin.shell: |
        for svc in {{ recovery_targets | join(' ') }}; do
          desired=$(kubectl get deploy $svc -n {{ target_namespace }} -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
          ready=$(kubectl get deploy $svc -n {{ target_namespace }} -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
          if [ "$desired" != "$ready" ]; then
            echo "[ROLLBACK] Restarting $svc (Desired=$desired, Ready=$ready)"
            kubectl rollout restart deploy $svc -n {{ target_namespace }} || true
          fi
        done
      register: restart_unready
      ignore_errors: yes
      changed_when: true

    - name: Show restart actions
      ansible.builtin.debug:
        var: restart_unready.stdout_lines

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6ï¸âƒ£ redis-cart â†” cartservice ì˜ì¡´ì„± ì •ë ¬
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Re-sync cartservice after redis-cart ready
      ansible.builtin.shell: |
        kubectl rollout status deploy/redis-cart -n {{ target_namespace }} --timeout=120s || true
        kubectl rollout restart deploy/cartservice -n {{ target_namespace }} || true
      register: cart_sync
      ignore_errors: yes
      changed_when: true

    - name: Show cartservice sync result
      ansible.builtin.debug:
        var: cart_sync.stdout_lines

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 7ï¸âƒ£ ì•ˆì •í™” ëŒ€ê¸° ë° ìµœì¢… ìƒíƒœ í™•ì¸
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Wait for recovery stabilization
      ansible.builtin.pause:
        seconds: "{{ recovery_wait }}"

    - name: Get final deployment status
      ansible.builtin.shell: |
        kubectl get deployments -n {{ target_namespace }} \
          -o custom-columns="NAME:.metadata.name,READY:.status.readyReplicas,DESIRED:.spec.replicas" --no-headers
      register: final_status
      ignore_errors: yes
      changed_when: false

    - name: Show final deployment summary
      ansible.builtin.debug:
        msg: |
          âœ… ìµœì¢… ë³µêµ¬ ìƒíƒœ
          {{ final_status.stdout | default('ì •ë³´ ì—†ìŒ') }}

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 8ï¸âƒ£ ë¡œê·¸ ê¸°ë¡ ë° ìš”ì•½
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Write recovery summary to log
      ansible.builtin.lineinfile:
        path: "{{ chaos_log_path }}"
        create: yes
        line: |
          [{{ ansible_date_time.iso8601 }}] Recovery ns={{ target_namespace }} result="{{ final_status.stdout | replace('\n','; ') }}"
      become: yes

    - name: âœ… Final recovery summary
      ansible.builtin.debug:
        msg: |
          âœ… Chaos Recovery Completed Successfully
          - Namespace: {{ target_namespace }}
          - Recovered Services: {{ recovery_targets | join(', ') }}
          - Final Status:
          {{ final_status.stdout | default('ì •ë³´ ì—†ìŒ') }}

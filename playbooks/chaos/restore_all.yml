# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# íŒŒì¼: playbooks/chaos/restore_all.yml
# ëª©ì :
#   - Chaos Mesh ì •ë¦¬ + (Fortio íŠ¸ë˜í”½ ìƒì„±ê¸° ì •ë¦¬) + ArgoCD ê°•ì œ Sync(kubectl-only)ë¡œ GitOps ì •ì„ ë³µêµ¬
#   - operation.sync íŠ¸ë¦¬ê±° â†’ Succeeded ëŒ€ê¸° â†’ Synced/Healthy ëŒ€ê¸° (3ë‹¨ê³„)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

- name: ğŸ”„ Unified GitOps Recovery via ArgoCD (kubectl-only, stable wait)
  hosts: k3s_master
  become: true

  vars:
    target_namespace: "app"
    chaos_log_path: "/var/log/chaos_recovery.log"

    argocd_ns: "argocd"
    argocd_app: "chaos-engineering"

    # íƒ€ì„ì•„ì›ƒ(ì´ˆ)
    op_timeout: 300
    sync_timeout: 300
    poll_interval: 5

    # Fortio íŠ¸ë˜í”½ ìƒì„±ê¸° ë¦¬ì†ŒìŠ¤ ì´ë¦„ (Job/Deployment ë‘˜ ë‹¤ ì •ë¦¬)
    fortio_job_name: "fortio-load"
    fortio_deploy_name: "fortio-loadgen"

    # ê°•ì œ sync ì˜µì…˜ (í•„ìš”ì‹œ ì¶”ê°€ ê°€ëŠ¥)
    # ì£¼ì˜: syncOptionsëŠ” ë¬¸ìì—´ ë°°ì—´
    argocd_sync_options:
      - "Prune=true"
      - "ApplyOutOfSyncOnly=true"
      - "Replace=true"

  tasks:
    # 1) Safety
    - name: Validate namespace safety
      ansible.builtin.assert:
        that:
          - target_namespace == "app"
        fail_msg: "âŒ namespaceê°€ 'app'ì´ ì•„ë‹™ë‹ˆë‹¤."
        success_msg: "âœ… namespace í™•ì¸ ì™„ë£Œ ({{ target_namespace }})"

    # 2) Chaos Mesh CR ì •ë¦¬
    - name: Remove all Chaos Mesh experiments
      ansible.builtin.shell: |
        set -e
        echo "[CLEANUP] Deleting Chaos Mesh CRs in {{ target_namespace }}..."
        kubectl -n {{ target_namespace }} delete networkchaos --all --ignore-not-found
        kubectl -n {{ target_namespace }} delete stresschaos --all --ignore-not-found
        kubectl -n {{ target_namespace }} delete podchaos --all --ignore-not-found
        kubectl -n {{ target_namespace }} delete iochaos --all --ignore-not-found
        kubectl -n {{ target_namespace }} delete httpchaos --all --ignore-not-found
        kubectl -n {{ target_namespace }} delete dnschaos --all --ignore-not-found
        kubectl -n {{ target_namespace }} delete timechaos --all --ignore-not-found
        echo "[OK] Chaos Mesh experiments removed."
      register: chaos_cleanup
      changed_when: true

    - name: Show chaos cleanup result
      ansible.builtin.debug:
        var: chaos_cleanup.stdout_lines

    # 3) helper pod ì •ë¦¬ (prefix íŒ¨í„´)
    - name: Remove leftover chaos helper pods
      ansible.builtin.shell: |
        set -e
        echo "[CLEANUP] Removing chaos helper pods..."
        PODS=$(kubectl get pods -n {{ target_namespace }} -o name | \
          grep -E '^pod/(cpu|net|network|svc|kill|chaos)-' || true)
        if [ -n "$PODS" ]; then
          echo "$PODS" | while read -r p; do
            kubectl delete "$p" -n {{ target_namespace }} --force --grace-period=0 || true
          done
        else
          echo "[INFO] No chaos helper pods found."
        fi
      register: helper_cleanup
      changed_when: true

    - name: Show helper pod cleanup result
      ansible.builtin.debug:
        var: helper_cleanup.stdout_lines

    # 3.5) âœ… Fortio íŠ¸ë˜í”½ ìƒì„±ê¸° ì •ë¦¬ (Deployment + Job)
    - name: Cleanup Fortio traffic generator (Deployment/Job)
      ansible.builtin.shell: |
        set -e
        echo "[CLEANUP] Removing fortio traffic generator..."
        kubectl -n {{ target_namespace }} delete deploy/{{ fortio_deploy_name }} --ignore-not-found
        kubectl -n {{ target_namespace }} delete job/{{ fortio_job_name }} --ignore-not-found
        echo "[OK] Fortio cleanup done."
      register: fortio_cleanup
      changed_when: true

    - name: Show fortio cleanup result
      ansible.builtin.debug:
        var: fortio_cleanup.stdout_lines

    # 4) Application ì¡´ì¬ í™•ì¸
    - name: Check ArgoCD Application exists
      ansible.builtin.shell: |
        kubectl -n {{ argocd_ns }} get application {{ argocd_app }} >/dev/null 2>&1
      changed_when: false

    # 5) âœ… kubectl-only ê°•ì œ Sync íŠ¸ë¦¬ê±° (operation.sync)
    - name: Trigger ArgoCD sync via operation.sync (force options)
      ansible.builtin.shell: |
        set -e
        echo "[SYNC] Triggering operation.sync for {{ argocd_app }}..."
        kubectl -n {{ argocd_ns }} patch application {{ argocd_app }} --type merge -p '{
          "operation": {
            "sync": {
              "prune": true,
              "syncOptions": {{ argocd_sync_options | to_json }}
            }
          }
        }'
      changed_when: true

    # 6) âœ… (1) operationState.phase Succeededê¹Œì§€ ëŒ€ê¸°
    - name: Wait until ArgoCD operationState.phase == Succeeded
      ansible.builtin.shell: |
        set -e
        echo "[WAIT] Waiting operationState.phase=Succeeded ..."
        end=$(( $(date +%s) + {{ op_timeout }} ))
        while [ $(date +%s) -lt $end ]; do
          phase=$(kubectl -n {{ argocd_ns }} get application {{ argocd_app }} \
            -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "")
          echo "  phase=${phase}"
          if [ "$phase" = "Succeeded" ]; then
            echo "[OK] operationState.phase=Succeeded"
            exit 0
          fi
          # Failed/Errorë„ ë¹ ë¥´ê²Œ ê°ì§€í•˜ê³  ëë‚´ê³  ì‹¶ìœ¼ë©´ ì•„ë˜ ì£¼ì„ í•´ì œ
          # if [ "$phase" = "Failed" ] || [ "$phase" = "Error" ]; then
          #   echo "[FAIL] operationState.phase=${phase}"
          #   exit 2
          # fi
          sleep {{ poll_interval }}
        done
        echo "[FAIL] Timeout waiting operationState.phase=Succeeded"
        exit 1
      changed_when: false

    # 7) âœ… (2) Synced & Healthyê¹Œì§€ ëŒ€ê¸°
    - name: Wait until ArgoCD app is Synced & Healthy
      ansible.builtin.shell: |
        set -e
        echo "[WAIT] Waiting sync=Synced & health=Healthy ..."
        end=$(( $(date +%s) + {{ sync_timeout }} ))
        while [ $(date +%s) -lt $end ]; do
          sync=$(kubectl -n {{ argocd_ns }} get application {{ argocd_app }} \
            -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          health=$(kubectl -n {{ argocd_ns }} get application {{ argocd_app }} \
            -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          echo "  sync=${sync} health=${health}"
          if [ "$sync" = "Synced" ] && [ "$health" = "Healthy" ]; then
            echo "[OK] ArgoCD app is Synced & Healthy"
            exit 0
          fi
          sleep {{ poll_interval }}
        done
        echo "[FAIL] Timeout waiting Synced/Healthy"
        exit 1
      changed_when: false

    # 8) selfHeal ë‹¤ì‹œ ON (ì •ìƒ ìš´ì˜ ë³µê·€)
    - name: Re-enable ArgoCD self-heal after recovery
      ansible.builtin.shell: |
        set -e
        echo "[ARGOCD] Re-enable selfHeal for app={{ argocd_app }}"
        kubectl -n {{ argocd_ns }} patch application {{ argocd_app }} --type merge -p '{
          "spec": {
            "syncPolicy": {
              "automated": {
                "selfHeal": true,
                "prune": true
              }
            }
          }
        }'
      changed_when: true

    # 9) ìµœì¢… ìƒíƒœ ì¶œë ¥
    - name: Get final deployment status
      ansible.builtin.shell: |
        kubectl get deployments -n {{ target_namespace }} \
          -o custom-columns="NAME:.metadata.name,READY:.status.readyReplicas,DESIRED:.spec.replicas" --no-headers
      register: final_status
      changed_when: false

    - name: Show final deployment summary
      ansible.builtin.debug:
        msg: |
          âœ… GitOps ê¸°ë°˜ Chaos Recovery ì™„ë£Œ (kubectl-only)
          - ArgoCD App: {{ argocd_app }}
          - Namespace: {{ target_namespace }}
          - Final Deployment Status:
          {{ final_status.stdout | default('ì •ë³´ ì—†ìŒ') }}

    # 10) ë¡œê·¸ ê¸°ë¡
    - name: Write recovery log
      ansible.builtin.lineinfile:
        path: "{{ chaos_log_path }}"
        create: true
        line: |
          [{{ ansible_date_time.iso8601 }}] Recovery OK app={{ argocd_app }} ns={{ target_namespace }} status="{{ final_status.stdout | default('') | replace('\n','; ') }}"
      become: true
      ignore_errors: true


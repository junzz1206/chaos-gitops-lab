# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# íŒŒì¼: roles/chaos_kill/tasks/main.yml
# ëª©ì :
#   - ì§€ì •ëœ ì„œë¹„ìŠ¤ì˜ Pod ê°•ì œ ì‚­ì œ ë° ìƒìœ„ ì˜¤ë¸Œì íŠ¸ ìë™ë³µêµ¬ ì°¨ë‹¨
#   - TARGET_SERVICES í™˜ê²½ë³€ìˆ˜ë¡œ ë‹¤ì¤‘ ì§€ì • ê°€ëŠ¥
#   - internal ì‹¤íŒ¨ ì‹œ ì„œë¹„ìŠ¤ë³„ external fallback (ì „ì²´ kill ì•„ë‹˜)
#   - CI/CD ì¤‘ë‹¨ ì‹œ ì•ˆì „ ì¢…ë£Œ
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

- name: Safety Check - Confirm namespace
  ansible.builtin.assert:
    that:
      - target_namespace == "app"
    fail_msg: "âŒ namespaceê°€ 'app'ì´ ì•„ë‹™ë‹ˆë‹¤. Chaos í…ŒìŠ¤íŠ¸ëŠ” app namespace ë‚´ì—ì„œë§Œ í—ˆìš©ë©ë‹ˆë‹¤."
    success_msg: "âœ… namespace í™•ì¸ ì™„ë£Œ ('app')"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Step 1ï¸âƒ£: Resolve target services dynamically
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- name: Resolve target services (ENV â†’ vars.yml â†’ random)
  vars:
    env_target_services: "{{ lookup('env', 'TARGET_SERVICES') | default('', true) }}"
  ansible.builtin.set_fact:
    target_services_effective: >-
      {{
        (env_target_services.split(',') | map('trim') | list)
        if env_target_services | length > 0
        else
          (
            [ target_app_label ]
            if (target_app_label is defined and target_app_label != "random")
            else []
          )
      }}
  changed_when: false

- name: Display resolved service targets
  ansible.builtin.debug:
    msg: |
      ğŸ¯ Chaos ëŒ€ìƒ ì„œë¹„ìŠ¤
      - ENV(TARGET_SERVICES): {{ lookup('env', 'TARGET_SERVICES') | default('N/A') }}
      - Vars(target_app_label): {{ target_app_label | default('N/A') }}
      - Effective Targets: {{ target_services_effective | join(', ') | default('N/A') }}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Step 2ï¸âƒ£: Disable auto-recovery for selected services
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- name: Disable auto-recovery for selected services
  when:
    - disable_autorecover | default(true)
    - target_services_effective | length > 0
  ansible.builtin.shell: |
    for svc in {{ target_services_effective | join(' ') }}; do
      echo "[DISABLE] Scaling down controllers for $svc..."
      kubectl get deploy -n {{ target_namespace }} -l app=$svc -o name | xargs -r -I{} kubectl scale {} -n {{ target_namespace }} --replicas=0 || true
      kubectl get rs -n {{ target_namespace }} -l app=$svc -o name | xargs -r -I{} kubectl scale {} -n {{ target_namespace }} --replicas=0 || true
      kubectl get sts -n {{ target_namespace }} -l app=$svc -o name | xargs -r -I{} kubectl scale {} -n {{ target_namespace }} --replicas=0 || true
    done
  register: disable_result
  ignore_errors: yes

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Step 3ï¸âƒ£: Internal Pod Kill (ìš°ì„  ì‹œë„)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- name: Attempt pod kill via internal exec
  when: target_services_effective | length > 0
  ansible.builtin.shell: |
    failed_services=""
    for svc in {{ target_services_effective | join(' ') }}; do
      echo "[TRY] Internal delete for $svc..."
      POD=$(kubectl get pod -n {{ target_namespace }} -l app=$svc -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
      if [ -n "$POD" ]; then
        # distroless ì»¨í…Œì´ë„ˆ ê°ì§€ (sh ì‹¤í–‰ ë¶ˆê°€ ì‹œ fallback ëŒ€ìƒ ë“±ë¡)
        kubectl exec -n {{ target_namespace }} $POD -- sh -c "echo ok" >/dev/null 2>&1 || failed_services="$failed_services $svc"
        echo "[DELETE] Killing pod(s) for $svc..."
        kubectl delete pod -n {{ target_namespace }} -l app=$svc --grace-period=0 --force || true
      else
        echo "[SKIP] No running pod found for $svc"
      fi
    done
    if [ -n "$failed_services" ]; then
      echo "[WARN] Internal mode not supported for:$failed_services"
      exit 99
    fi
  register: internal_kill_result
  ignore_errors: yes

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Step 4ï¸âƒ£: Auto Fallback (internal â†’ external per service)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- name: Fallback to external chaos for failed internal services
  when: internal_kill_result.rc != 0
  ansible.builtin.shell: |
    echo "[FALLBACK] Switching to external chaos mode for specific services..."
    for svc in {{ target_services_effective | join(' ') }}; do
      echo "[EXTERNAL] Injecting chaos for $svc via helper pod..."
      kubectl run chaos-kill-$svc --image=nicolaka/netshoot:latest --restart=Never -n {{ target_namespace }} \
        --overrides='{
          "spec": {
            "containers": [{
              "name": "chaos-kill",
              "image": "nicolaka/netshoot:latest",
              "command": ["/bin/sh", "-c"],
              "args": [
                "echo \"[EXTERNAL CHAOS] Forcing delete of $svc pods...\"; \
                 kubectl delete pod -n {{ target_namespace }} -l app=$svc --grace-period=0 --force || true; \
                 sleep {{ chaos_duration | default(30) }}; \
                 echo \"[EXTERNAL CHAOS] Done for $svc.\";"
              ]
            }]
          }
        }' || true
    done
  register: fallback_result
  ignore_errors: yes

- name: Print fallback result
  when: internal_kill_result.rc != 0
  ansible.builtin.debug:
    msg: |
      âš ï¸ Internal mode failed; fallback to service-specific external chaos
      {{ fallback_result.stdout | default('No log output') }}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Step 5ï¸âƒ£: Random Chaos Mode (fallback if no service specified)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- name: Execute random chaos mode
  when: (target_services_effective | length == 0) or (target_app_label | default('random') == 'random')
  ansible.builtin.shell: |
    chaos_targets="frontend productcatalogservice cartservice checkoutservice paymentservice shippingservice emailservice redis-cart"
    svc=$(shuf -e $chaos_targets -n 1)
    echo "[RANDOM] Randomly selected: $svc"
    kubectl delete pod -n {{ target_namespace }} -l app=$svc --grace-period=0 --force || true
  register: random_kill_result
  ignore_errors: yes

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Step 6ï¸âƒ£: Verification / Logging
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- name: Wait for chaos duration
  ansible.builtin.pause:
    seconds: "{{ chaos_duration | default(30) }}"

- name: Verify non-running pods
  ansible.builtin.shell: |
    kubectl get pods -n {{ target_namespace }} --field-selector=status.phase!=Running
  register: non_running_pods
  ignore_errors: yes

- name: Display final result
  ansible.builtin.debug:
    msg: |
      âœ… Chaos í…ŒìŠ¤íŠ¸ ì™„ë£Œ
      ë¹„ì •ìƒ Pod ëª©ë¡:
      {{ non_running_pods.stdout | default('None (All Running)') }}

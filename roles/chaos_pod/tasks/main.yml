# ëª©ì :
#   - ë„¤ìž„ìŠ¤íŽ˜ì´ìŠ¤ ë‚´ íŠ¹ì • ë˜ëŠ” ë¬´ìž‘ìœ„ Pod ì‚­ì œ (ë¼ë²¨ ê¸°ë°˜)
#   - disable_autorecover=true ì‹œ ReplicaSet ìžë™ë³µêµ¬ ì°¨ë‹¨
#   - chaos_log_path_finalì— ê²°ê³¼ ê¸°ë¡
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Step 0ï¸âƒ£: Safety Checks
- name: "Safety Check - ensure target_namespace variable exists"
  ansible.builtin.assert:
    that:
      - target_namespace is defined
    fail_msg: "âŒ target_namespace ë³€ìˆ˜ê°€ ì •ì˜ë˜ì–´ ìžˆì§€ ì•ŠìŠµë‹ˆë‹¤. ì˜ˆ: -e 'target_namespace=app'"
    success_msg: "âœ… target_namespace ë³€ìˆ˜ í™•ì¸ë¨: {{ target_namespace }}"

- name: "Safety Check - ensure running in test namespace 'app' by default"
  ansible.builtin.assert:
    that:
      - (target_namespace | default('app')) == "app"
    fail_msg: "âš ï¸ ì•ˆì „ìž¥ì¹˜: target_namespaceê°€ 'app'ì´ ì•„ë‹™ë‹ˆë‹¤. Chaos í…ŒìŠ¤íŠ¸ ì „ í™•ì¸ í•„ìš”."
    success_msg: "âœ… namespace ì•ˆì „ê²€ì‚¬ í†µê³¼ ({{ target_namespace }})"

# Step 1ï¸âƒ£: Variable Initialization
- name: "Set defaults for optional variables (safe defaults)"
  ansible.builtin.set_fact:
    chaos_log_path_final: "{{ chaos_log_path | default('/var/log/chaos_test.log') }}"
    random_pod_kill_count_safe: "{{ (random_pod_kill_count | int) if (random_pod_kill_count is defined and (random_pod_kill_count | int) > 0) else 2 }}"
    chaos_duration_safe: "{{ (chaos_duration | int) if (chaos_duration is defined and (chaos_duration | int) > 0) else 10 }}"
  changed_when: false

- name: "Display run parameters"
  ansible.builtin.debug:
    msg: |
      ðŸ§¨ Chaos Pod Kill ì‹œìž‘
      - namespace: {{ target_namespace }}
      - delete_count: {{ random_pod_kill_count_safe }}
      - chaos_duration: {{ chaos_duration_safe }}ì´ˆ
      - log_path: {{ chaos_log_path_final }}
      - target_pod_names: {{ target_pod_names | join(', ') if (target_pod_names is defined and target_pod_names | length > 0) else 'ì—†ìŒ (ëžœë¤ ëŒ€ìƒ)' }}
      - disable_autorecover: {{ disable_autorecover | default(false) }}

# Step 2ï¸âƒ£: Disable auto-recover (optional)
- name: "Find ReplicaSets in target namespace"
  when: disable_autorecover | default(false)
  ansible.builtin.shell: |
    kubectl get rs -n {{ target_namespace }} -o jsonpath='{.items[*].metadata.name}'
  register: rs_list_raw
  changed_when: false

- name: "Scale down all ReplicaSets to disable auto recovery"
  when: disable_autorecover | default(false)
  ansible.builtin.shell: |
    for rs in {{ rs_list_raw.stdout }}; do
      echo "Scaling down ReplicaSet: $rs"
      kubectl scale rs "$rs" -n {{ target_namespace }} --replicas=0 || true
    done
  ignore_errors: yes
  changed_when: true

# Step 3ï¸âƒ£: Resolve actual pods dynamically by label
- name: "Resolve real pod names from labels"
  when: target_pod_names is defined and target_pod_names | length > 0
  ansible.builtin.shell: |
    kubectl get pods -n {{ target_namespace }} -l app={{ item }} -o jsonpath='{.items[*].metadata.name}'
  loop: "{{ target_pod_names }}"
  register: resolved_pods
  changed_when: false

- name: "Collect resolved pod names"
  when: target_pod_names is defined and target_pod_names | length > 0
  ansible.builtin.set_fact:
    selected_pods: "{{ resolved_pods.results | map(attribute='stdout') | map('split') | sum(start=[]) }}"
  changed_when: false

# Step 4ï¸âƒ£: If no specific targets, select random running pods
- name: "Get running pods in namespace (random mode)"
  when: target_pod_names is not defined or target_pod_names | length == 0
  ansible.builtin.shell: |
    kubectl get pods -n {{ target_namespace }} --field-selector=status.phase=Running -o name --no-headers
  register: all_pods
  changed_when: false

- name: "Select random pods for chaos"
  when: target_pod_names is not defined or target_pod_names | length == 0
  ansible.builtin.set_fact:
    selected_pods: "{{ (all_pods.stdout_lines | shuffle)[: (random_pod_kill_count_safe | int)] }}"
  changed_when: false

- name: "Debug - show selected pods"
  ansible.builtin.debug:
    msg: "ðŸ—‘ï¸   ì‚­ì œ ëŒ€ìƒ Pod: {{ selected_pods }}"

# Step 5ï¸âƒ£: Delete selected pods (forced)
- name: "Delete selected pods (grace-period=0, force)"
  ansible.builtin.shell: |
    set -eux
    for p in {{ selected_pods | join(' ') }}; do
      echo "Deleting pod: $p"
      kubectl delete pod "$p" -n {{ target_namespace }} --grace-period=0 --force || echo "â— kubectl delete failed for $p"
    done
  register: kill_result
  ignore_errors: yes
  changed_when: true

- name: "Write deletion stdout to debug"
  ansible.builtin.debug:
    var: kill_result.stdout_lines

# Step 6ï¸âƒ£: Wait for chaos_duration
- name: "Pause to allow scheduler to react"
  ansible.builtin.pause:
    seconds: "{{ chaos_duration_safe }}"

# Step 7ï¸âƒ£: Verify state
- name: "Check Running pods after chaos"
  ansible.builtin.shell: |
    kubectl get pods -n {{ target_namespace }} --field-selector=status.phase=Running --no-headers | wc -l
  register: recovery_count
  changed_when: false

- name: "Show running pod count after chaos"
  ansible.builtin.debug:
    msg: "ðŸ“Š Post-chaos Running pod count: {{ recovery_count.stdout }}"

# Step 8ï¸âƒ£: Re-enable auto recovery
- name: "Re-enable ReplicaSet auto recovery (scale up)"
  when: disable_autorecover | default(false)
  ansible.builtin.shell: |
    for rs in {{ rs_list_raw.stdout }}; do
      echo "Restoring ReplicaSet: $rs"
      kubectl scale rs "$rs" -n {{ target_namespace }} --replicas=1 || true
    done
  ignore_errors: yes
  changed_when: true

# Step 9ï¸âƒ£: Persist log
- name: "Persist chaos result to log"
  ansible.builtin.lineinfile:
    path: "{{ chaos_log_path_final }}"
    create: true
    line: |
      [{{ ansible_date_time.iso8601 }}] PodChaos: ns={{ target_namespace }} deleted={{ selected_pods | join(',') }} count={{ selected_pods | length }} running_after={{ recovery_count.stdout }}
  become: true
  when: recovery_count is defined

# Step ðŸ”Ÿ: Summary
- name: "Final debug summary"
  ansible.builtin.debug:
    msg: |
      âœ… Chaos Pod Kill ì™„ë£Œ.
      - namespace: {{ target_namespace }}
      - deleted_pods: {{ selected_pods | join(', ') }}
      - total_deleted: {{ selected_pods | length }}
      - running_after: {{ recovery_count.stdout }}
# Step 1.5ï¸âƒ£: Dynamic Target Resolution (CI/CD í™˜ê²½ë³€ìˆ˜ or íŒŒì¼)
- name: "Resolve target pod names from environment variable or file"
  vars:
    env_target_pods: "{{ lookup('env', 'TARGET_PODS') | default('', true) }}"
  block:
    - name: "Load pod targets from CI/CD environment variable"
      when: env_target_pods | length > 0
      ansible.builtin.set_fact:
        target_pod_names: "{{ env_target_pods.split(',') }}"
      changed_when: false

    - name: "Load pod targets from pod_kill_targets.yml (fallback)"
      when:
        - (target_pod_names is not defined or target_pod_names | length == 0)
        - lookup('file', '{{ playbook_dir }}/../../pod_kill_targets.yml', errors='ignore') is not none
      ansible.builtin.include_vars:
        file: "{{ playbook_dir }}/../../pod_kill_targets.yml"
        name: pod_targets_fallback

    - name: "Apply fallback target list from pod_kill_targets.yml"
      when:
        - target_pod_names is not defined or target_pod_names | length == 0
        - pod_targets_fallback is defined and pod_targets_fallback.pod_targets is defined
      ansible.builtin.set_fact:
        target_pod_names: "{{ pod_targets_fallback.pod_targets }}"
      changed_when: false

    - name: "Show resolved pod targets (env or file)"
      ansible.builtin.debug:
        msg: |
          ðŸŽ¯ Target pods resolved:
          - From ENV: {{ env_target_pods if env_target_pods | length > 0 else 'N/A' }}
          - From File: {{ pod_targets_fallback.pod_targets | default([]) }}
          - Effective: {{ target_pod_names | default([]) }}

